include "./Telegraf.tessla"

@TelegrafIn("amqp_consumer","host=<HOST>", "lid_open")
in lidOpen: Events[Bool]

@TelegrafIn("amqp_consumer","host=<HOST>", "energy_saver_on")
in energySaver: Events[Bool] 

@TelegrafIn("amqp_consumer","host=<HOST>", "reset")
in reset: Events[Bool] 

def prev_prev[D](s : Events[D]) : Events[D] = {
  prev(prev(s))
}

def prev_prev_prev[D](s : Events[D]) = {
  prev(prev_prev(s))
}

# Checks if v is `check`. If v is not defined then default to `check`
def eq_with_default(s : Events[Bool], check : Bool) = merge(s, check) == check

def es_turns_on = energySaver || eq_with_default(prev(energySaver), true) || eq_with_default(prev_prev(energySaver), true) || eq_with_default(prev_prev_prev(energySaver), true)

# Indicates if the lid has been closed for more than three samples
def lid_closed_long = !lidOpen || eq_with_default(prev(lidOpen), false) || eq_with_default(prev_prev(lidOpen), false) || eq_with_default(prev_prev_prev(lidOpen), false)

# Turn on alert when the lid was opened for more than three samples and energy-saving never turned on
def alert = !lid_closed_long && !es_turns_on

# Simultaneous events? Prioritize first.
# When reset = true - stream = false
# boolFilter filters out all false values. So only care about alert when it becomes true.
# False is the default value.
def continousAlarm : Events[Bool] = merge3(!reset, boolFilter(alert), false)

# Send a verdict whenever lidOpen, energySaver or reset updates
def continousAlarmTick = merge3(on(lidOpen, continousAlarm), on(energySaver, continousAlarm), on(reset, continousAlarm))

@TelegrafOut("alert") 
out continousAlarmTick